// Load environment variables first
import dotenv from 'dotenv';
dotenv.config();

import { getGoogleCalendarClient } from '../utils/googleCalendarClient';
import { prisma } from '../lib/prisma';

/**
 * Aggressive cleanup script to remove ALL events from a user's Google Calendar
 * that contain specific keywords (like "2014 Black" or "Richardson")
 * Usage: npx ts-node src/scripts/cleanupAllGoogleCalendarEvents.ts <user_email>
 */

async function cleanupAllGoogleCalendarEvents(userEmail: string) {
  console.log(`\nüßπ Starting aggressive cleanup for user: ${userEmail}\n`);

  // Find user by email
  const user = await prisma.user.findUnique({
    where: { email: userEmail },
    select: {
      id: true,
      email: true,
      google_calendar_id: true,
      google_calendar_sync_enabled: true,
    },
  });

  if (!user) {
    console.error(`‚ùå User not found: ${userEmail}`);
    process.exit(1);
  }

  console.log(`‚úÖ Found user: ${user.email} (${user.id})`);

  if (!user.google_calendar_sync_enabled) {
    console.log(`‚ö†Ô∏è  Google Calendar sync is not enabled for this user`);
    process.exit(0);
  }

  // Get Google Calendar client
  const calendar = await getGoogleCalendarClient(user.id);
  const calendarId = user.google_calendar_id || 'primary';

  console.log(`\nüìÖ Fetching all events from Google Calendar...\n`);

  // Fetch all events from the calendar (next 2 years)
  const now = new Date();
  const twoYearsFromNow = new Date();
  twoYearsFromNow.setFullYear(now.getFullYear() + 2);

  const response = await calendar.events.list({
    calendarId,
    timeMin: '2020-01-01T00:00:00Z', // Start from 2020 to catch old events
    timeMax: twoYearsFromNow.toISOString(),
    maxResults: 2500,
    singleEvents: true,
  });

  const events = response.data.items || [];
  console.log(`üìä Found ${events.length} total events in Google Calendar\n`);

  // Filter for Koordie-related events (events with "2014 Black", "Richardson", or generated by Koordie)
  const koordiEvents = events.filter(event => {
    const summary = event.summary || '';
    const description = event.description || '';
    
    // Check if it's a Koordie event
    return (
      summary.includes('2014 Black') ||
      summary.includes('Richardson') ||
      description.includes('Child: Xander') ||
      description.includes('Calendar: Towson United')
    );
  });

  console.log(`üéØ Found ${koordiEvents.length} Koordie-related events to delete\n`);

  if (koordiEvents.length === 0) {
    console.log(`‚úÖ No Koordie events to clean up`);
    process.exit(0);
  }

  let successCount = 0;
  let errorCount = 0;

  // Delete each event
  for (const event of koordiEvents) {
    try {
      await calendar.events.delete({
        calendarId,
        eventId: event.id!,
      });

      successCount++;
      console.log(`‚úÖ Deleted: ${event.summary}`);
    } catch (error: any) {
      errorCount++;
      console.error(`‚ùå Failed to delete "${event.summary}": ${error.message}`);
    }
  }

  console.log(`\nüìä Cleanup Summary:`);
  console.log(`   ‚úÖ Successfully deleted: ${successCount}`);
  console.log(`   ‚ùå Failed to delete: ${errorCount}`);
  console.log(`\n‚ú® Cleanup complete!\n`);
}

// Get user email from command line arguments
const userEmail = process.argv[2];

if (!userEmail) {
  console.error('‚ùå Usage: npx ts-node src/scripts/cleanupAllGoogleCalendarEvents.ts <user_email>');
  process.exit(1);
}

cleanupAllGoogleCalendarEvents(userEmail)
  .catch((error) => {
    console.error('‚ùå Cleanup failed:', error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
